using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class PlatformManagerOld : MonoBehaviour {

	public Color LevelColour;
	public Color InProgressColour;
	public Color NextColour;
	public Color ScoreColour;
	//public GameObject Tile;
	//public GameObject TileColourSwitch;
	public GameObject TileDrag;
	public GameObject BorderTile;
	public GameObject BorderTileDrag;
	public GameObject CircleObject;
	public GameObject SquareObject;
	public GameObject HintScreenObject;
	public GameObject HintObject;
	public GameObject TimerSliderObject;
	public GameObject TimerLineObject;
	public GameObject TimerCircleObject;
	public float PlatformBaseOffset = 0.1f;
	public float gridSpace = 0.1f;

	public float scoreCircleOffsetX = 1.5f;

	bool showScoreCircles = false;
	Vector3 hintButtonPos;
	Vector3 currentScoreCirclePos, prevScoreCircleFarPos, prevScoreCircleNearPos, nextScoreCircleNearPos, nextScoreCircleFarPos;
	Vector3 timerCircle3Pos, timerCircle2Pos, timerCircle1Pos, timerSliderInitPos;
	Vector3 hintScreenSize, hintScreenCollapseSize, timerLineSize, timerLineCollapseSize;
	public bool ShowHintScreenFlag = false;
	public bool HideHintScreenFlag = false;
	bool ColourTimerCirclesFlag = false;
	GameObject levelSquare;
	GameObject hintButton;
	GameObject hintScreen;
	GameObject timerLine, timerSlider, timerCircle3Star, timerCircle2Star, timerCircle1Star;
	GameObject currentScoreCircle, prevScoreCircleFar, prevScoreCircleNear, nextScoreCircleNear, nextScoreCircleFar;
	float circleSpeed = 5;
	float circleAlphaNear = 0.3f;
	float circleAlphaFar = 0.6f;
	float alphaSpeed = 10;
	float ang = 0;
	float maxAng = 45;
	float timerStartCounter3, timerStartCounter2, timerStartCounter1;
	List<GameObject> tilesToFlip = new List<GameObject> ();

	bool ScoreCompleteFlag = false;

	bool flipTilesFlag = false;

	[HideInInspector]
	public bool StartTimerFlag = false;

	Dictionary<string, Color> colourDict;

	GameManager gameManager;
	CameraBehaviour cameraManager;
	TimeManager timeManager;

	Dictionary<string, string> hintDict;

	void Awake(){
		gameManager = FindObjectOfType<GameManager>();
		cameraManager = FindObjectOfType<CameraBehaviour>();
		timeManager = FindObjectOfType<TimeManager>();

		hintDict = PopulateHintDictionry ();
		colourDict = FindObjectOfType<ColourManager> ().PopulateColourDictionary ();
		//TilePuzzleNum = 3;
	}

	void Start(){

	}

	void Update(){
		if (showScoreCircles && cameraManager.cameraAdjusted) {

			if (ang < maxAng) {
				ang += Time.deltaTime * 300;
			} else {
				ang = maxAng;
			}
			levelSquare.transform.localRotation = Quaternion.AngleAxis (ang, Vector3.back);

			Color myColor = currentScoreCircle.GetComponent<SpriteRenderer> ().color;
			Color _color = myColor;
			_color.a = 1f;
			Color newColor = Color.Lerp(myColor, _color, alphaSpeed*Time.deltaTime);
			currentScoreCircle.GetComponent<SpriteRenderer> ().color = newColor;
			currentScoreCircle.GetComponentInChildren<Text> ().color = newColor;
			currentScoreCircle.transform.localPosition = Vector3.Lerp(currentScoreCircle.transform.localPosition, currentScoreCirclePos, circleSpeed*Time.deltaTime);

			myColor = prevScoreCircleFar.GetComponent<SpriteRenderer> ().color;
			_color = myColor;
			_color.a = circleAlphaNear;
			newColor = Color.Lerp(myColor, _color, alphaSpeed*Time.deltaTime);
			prevScoreCircleFar.GetComponent<SpriteRenderer> ().color = newColor;
			prevScoreCircleFar.GetComponentInChildren<Text> ().color = newColor;
			prevScoreCircleFar.transform.localPosition = Vector3.Lerp(prevScoreCircleFar.transform.localPosition, prevScoreCircleFarPos, circleSpeed*Time.deltaTime);

			myColor = prevScoreCircleNear.GetComponent<SpriteRenderer> ().color;
			_color = myColor;
			_color.a = circleAlphaFar;
			newColor = Color.Lerp(myColor, _color, alphaSpeed*Time.deltaTime);
			prevScoreCircleNear.GetComponent<SpriteRenderer> ().color = newColor;
			prevScoreCircleNear.GetComponentInChildren<Text> ().color = newColor;
			prevScoreCircleNear.transform.localPosition = Vector3.Lerp(prevScoreCircleNear.transform.localPosition, prevScoreCircleNearPos, circleSpeed*Time.deltaTime);

			myColor = nextScoreCircleNear.GetComponent<SpriteRenderer> ().color;
			_color = myColor;
			_color.a = circleAlphaNear;
			newColor = Color.Lerp(myColor, _color, alphaSpeed*Time.deltaTime);
			nextScoreCircleNear.GetComponent<SpriteRenderer> ().color = newColor;
			nextScoreCircleNear.GetComponentInChildren<Text> ().color = newColor;
			nextScoreCircleNear.transform.localPosition = Vector3.Lerp(nextScoreCircleNear.transform.localPosition, nextScoreCircleNearPos, circleSpeed*Time.deltaTime);

			myColor = nextScoreCircleFar.GetComponent<SpriteRenderer> ().color;
			_color = myColor;
			_color.a = circleAlphaNear;
			newColor = Color.Lerp(myColor, _color, alphaSpeed*Time.deltaTime);
			nextScoreCircleFar.GetComponent<SpriteRenderer> ().color = newColor;
			nextScoreCircleFar.GetComponentInChildren<Text> ().color = newColor;
			nextScoreCircleFar.transform.localPosition = Vector3.Lerp(nextScoreCircleFar.transform.localPosition, nextScoreCircleFarPos, circleSpeed*Time.deltaTime);

			myColor = hintButton.GetComponent<SpriteRenderer> ().color;
			_color = myColor;
			_color.a = 1f;
			newColor = Color.Lerp(myColor, _color, alphaSpeed*Time.deltaTime);
			hintButton.GetComponent<SpriteRenderer> ().color = newColor;
			hintButton.transform.localPosition = Vector3.Lerp(hintButton.transform.localPosition, hintButtonPos, circleSpeed*Time.deltaTime);

			if (prevScoreCircleFar.transform.localPosition == prevScoreCircleFarPos) {
				showScoreCircles = false;
			}

			timerCircle3Star.transform.localPosition = Vector3.Lerp (timerCircle3Star.transform.localPosition, timerCircle3Pos, circleSpeed * Time.deltaTime);
			timerCircle2Star.transform.localPosition = Vector3.Lerp (timerCircle2Star.transform.localPosition, timerCircle2Pos, circleSpeed * Time.deltaTime);
			timerCircle1Star.transform.localPosition = Vector3.Lerp (timerCircle1Star.transform.localPosition, timerCircle1Pos, circleSpeed * Time.deltaTime);

		}

		if (ShowHintScreenFlag) {
			hintScreen.transform.localScale = Vector3.Lerp (hintScreen.transform.localScale, hintScreenSize, circleSpeed * Time.deltaTime);
		}

		if (HideHintScreenFlag) {
			hintScreen.transform.localScale = Vector3.Lerp (hintScreen.transform.localScale, hintScreenCollapseSize, circleSpeed * Time.deltaTime);
		}

		if (ColourTimerCirclesFlag) {
			timerCircle3Star.GetComponent<SpriteRenderer> ().color = Color.Lerp (timerCircle3Star.GetComponent<SpriteRenderer> ().color, colourDict ["TimerColour3Star"], alphaSpeed * Time.deltaTime);
			timerCircle2Star.GetComponent<SpriteRenderer> ().color = Color.Lerp (timerCircle2Star.GetComponent<SpriteRenderer> ().color, colourDict ["TimerColour2Star"], alphaSpeed * Time.deltaTime);
			timerCircle1Star.GetComponent<SpriteRenderer> ().color = Color.Lerp (timerCircle1Star.GetComponent<SpriteRenderer> ().color, colourDict ["TimerColour1Star"], alphaSpeed * Time.deltaTime);
		}

		if (StartTimerFlag) {
			//timerLine.transform.localScale = Vector3.Lerp (timerLine.transform.localScale, timerLineCollapseSize, Time.deltaTime / time1Star);
			if(!timerSlider.activeSelf)
				timerSlider.SetActive(true);



			if (timeManager.GetCurrentTime () < timeManager.time3star) {
				timerStartCounter3 += Time.deltaTime / timeManager.time3star;
				timerSlider.transform.localPosition = Vector3.Lerp (timerSliderInitPos, timerCircle3Star.transform.localPosition, timerStartCounter3);
				timerSlider.GetComponent<SpriteRenderer> ().color = colourDict ["TimerColour3Star"];

			} else if (timeManager.GetCurrentTime () < timeManager.time2star) {
				timerStartCounter2 += Time.deltaTime / (timeManager.time2star - timeManager.time3star);
				timerSlider.transform.localPosition = Vector3.Lerp (timerCircle3Star.transform.localPosition, timerCircle2Star.transform.localPosition, timerStartCounter2);
				timerSlider.GetComponent<SpriteRenderer> ().color = colourDict ["TimerColour2Star"];
				timerCircle3Star.GetComponent<SpriteRenderer> ().color = colourDict ["TimerColourOff"];

			} else if (timeManager.GetCurrentTime () < timeManager.time1star) {
				timerStartCounter1 += Time.deltaTime / (timeManager.time1star - timeManager.time2star);
				timerSlider.transform.localPosition = Vector3.Lerp (timerCircle2Star.transform.localPosition, timerCircle1Star.transform.localPosition, timerStartCounter1);
				timerSlider.GetComponent<SpriteRenderer> ().color = colourDict ["TimerColour1Star"];
				timerCircle2Star.GetComponent<SpriteRenderer> ().color = colourDict ["TimerColourOff"];
				timerCircle3Star.GetComponent<SpriteRenderer> ().color = colourDict ["TimerColourOff"];
			} else {
				timerCircle2Star.GetComponent<SpriteRenderer> ().color = colourDict ["TimerColourOff"];
				timerCircle3Star.GetComponent<SpriteRenderer> ().color = colourDict ["TimerColourOff"];
			}

//			if (timeManager.GetCurrentTime () > timeManager.time3star)
//				timerCircle3Star.GetComponent<SpriteRenderer> ().color = colourDict ["TimerColourOff"];
//			else if(timeManager.GetCurrentTime () > timeManager.time2star)
//				timerCircle2Star.GetComponent<SpriteRenderer> ().color = colourDict ["TimerColourOff"];
			
//			timerCircle3Star.transform.localPosition = Vector3.Lerp (timerCircle3Star.transform.localPosition, timerCircle3Pos, circleSpeed * Time.deltaTime);
//			timerCircle2Star.transform.localPosition = Vector3.Lerp (timerCircle2Star.transform.localPosition, timerCircle2Pos, circleSpeed * Time.deltaTime);
//			timerCircle1Star.transform.localPosition = Vector3.Lerp (timerCircle1Star.transform.localPosition, timerCircle1Pos, circleSpeed * Time.deltaTime);
		}

		if (ScoreCompleteFlag) {

			Color myColor = prevScoreCircleFar.GetComponent<SpriteRenderer> ().color;
			Color _color = myColor;
			_color.a = 0f;
			Color newColor = Color.Lerp(myColor, _color, alphaSpeed*Time.deltaTime);
			prevScoreCircleFar.GetComponent<SpriteRenderer> ().color = newColor;
			prevScoreCircleFar.GetComponentInChildren<Text> ().color = newColor;

			myColor = prevScoreCircleNear.GetComponent<SpriteRenderer> ().color;
			_color = myColor;
			_color.a = 0f;
			newColor = Color.Lerp(myColor, _color, alphaSpeed*Time.deltaTime);
			prevScoreCircleNear.GetComponent<SpriteRenderer> ().color = newColor;
			prevScoreCircleNear.GetComponentInChildren<Text> ().color = newColor;

			myColor = nextScoreCircleNear.GetComponent<SpriteRenderer> ().color;
			_color = myColor;
			_color.a = 0f;
			newColor = Color.Lerp(myColor, _color, alphaSpeed*Time.deltaTime);
			nextScoreCircleNear.GetComponent<SpriteRenderer> ().color = newColor;
			nextScoreCircleNear.GetComponentInChildren<Text> ().color = newColor;

			myColor = nextScoreCircleFar.GetComponent<SpriteRenderer> ().color;;
			_color = myColor;
			_color.a = 0f;
			newColor = Color.Lerp(myColor, _color, alphaSpeed*Time.deltaTime);
			nextScoreCircleFar.GetComponent<SpriteRenderer> ().color = newColor;
			nextScoreCircleFar.GetComponentInChildren<Text> ().color = newColor;

			prevScoreCircleFar.transform.localPosition = Vector3.MoveTowards(prevScoreCircleFar.transform.localPosition, currentScoreCircle.transform.localPosition, circleSpeed*Time.deltaTime);
			prevScoreCircleNear.transform.localPosition = Vector3.MoveTowards(prevScoreCircleNear.transform.localPosition, currentScoreCircle.transform.localPosition, circleSpeed*Time.deltaTime);
			nextScoreCircleNear.transform.localPosition = Vector3.MoveTowards(nextScoreCircleNear.transform.localPosition, currentScoreCircle.transform.localPosition, circleSpeed*Time.deltaTime);
			nextScoreCircleFar.transform.localPosition = Vector3.MoveTowards(nextScoreCircleFar.transform.localPosition, currentScoreCircle.transform.localPosition, circleSpeed*Time.deltaTime);

//			prevScoreCircleFar.transform.localPosition = currentScoreCircle.transform.localPosition;
//			prevScoreCircleNear.transform.localPosition = currentScoreCircle.transform.localPosition;
//			nextScoreCircleNear.transform.localPosition = currentScoreCircle.transform.localPosition;
//			nextScoreCircleFar.transform.localPosition = currentScoreCircle.transform.localPosition;

			newColor = Color.Lerp(currentScoreCircle.GetComponent<SpriteRenderer> ().color, LevelColour, alphaSpeed*Time.deltaTime);
			currentScoreCircle.GetComponent<SpriteRenderer> ().color = newColor;
			currentScoreCircle.GetComponentInChildren<Text> ().color = newColor;

			float dist = Vector3.Distance (prevScoreCircleFar.transform.localPosition,currentScoreCircle.transform.localPosition);
			//if (dist < 1f) {

			if(prevScoreCircleFar.transform.localPosition == currentScoreCircle.transform.localPosition){
			//if (prevScoreCircleFar.transform.localPosition == currentScoreCircle.transform.localPosition) {
				print ("SCORE COMPLETED.....");

				//Flip tiles to show menu items
				flipTilesFlag = true;
				ScoreCompleteFlag = false;
					
			}
		}

		if (flipTilesFlag) {
			FlipTiles();
		}
		
	}

	void FlipTiles(){

		foreach (GameObject tile in tilesToFlip) {
			//yield return new WaitForSeconds (0.5f);
			Quaternion _targetRotation = Quaternion.Euler(new Vector3(180, 0, 0));
			tile.transform.localRotation = Quaternion.Lerp(tile.transform.localRotation, _targetRotation, 6f * Time.deltaTime);
			if (!tile.GetComponent<TileDragBehaviour> ().isFlipped && tile.transform.localRotation.x < -0.5f) {
				tile.GetComponent<TileDragBehaviour> ().isFlipped = true;
				tile.GetComponent<ITileInterface> ().SetTileCode (2);
			}
				
		}
	}

	public void populateGrid(int width, int hight, int iterations){

		GameObject currTile = new GameObject();
		GameObject currBorderTile = new GameObject();

//		if (gameManager.puzzleNum == 0 || gameManager.puzzleNum == 2 || gameManager.puzzleNum == 6) {
//			currTile = Tile;
//			currBorderTile = BorderTile;
//		} else if (gameManager.puzzleNum == 1) {
//			currTile = TileColourSwitch;
//			currBorderTile = BorderTile;
//		} else if (gameManager.puzzleNum == 3 || gameManager.puzzleNum == 4 || gameManager.puzzleNum == 5) {
//			currTile = TileDrag;
//			currBorderTile = BorderTileDrag;
//		}

		if (gameManager.puzzleNum == 0 || gameManager.puzzleNum == 1 || gameManager.puzzleNum == 2) {
			currTile = TileDrag;
			currBorderTile = BorderTileDrag;
		}


		for (int k = 0; k < iterations; k++) {

			for (int i = 0; i < hight; i++) {
				for (int j = 0; j < width; j++) {
					if (j == 0 && k != 0) {
						continue;
					}
					GameObject myObj;

					if (i == 0 || i == hight - 1) {
						myObj = (GameObject)Instantiate (currBorderTile, transform);
					} else if(j == 0 || j == width - 1) {
						myObj = (GameObject)Instantiate (currBorderTile, transform);
					} else {
						myObj = (GameObject)Instantiate (currTile, transform);	
					}

					float myWidth;
					if (k != 0) {
						myWidth = width - 1;
					} else {
						myWidth = width;
					}

					float xSize = myObj.GetComponent<SpriteRenderer> ().sprite.bounds.size.x * myObj.transform.localScale.x;
					float ySize = myObj.GetComponent<SpriteRenderer> ().sprite.bounds.size.y * myObj.transform.localScale.y;
					float horizontalShift = j * xSize + j*gridSpace;
					float iterationShift = k * (xSize + gridSpace) * myWidth;
					horizontalShift = horizontalShift - (xSize + gridSpace) * (width/2) + iterationShift;
					float verticalShift = -i * ySize - i*gridSpace;
					verticalShift = verticalShift + (ySize + gridSpace) * (hight/2);
					myObj.transform.Translate (horizontalShift, verticalShift, 0);

				}
				 
			}
		}

		Vector3 centerPoint = GetCenterPoint();
		float xDist = centerPoint.x - transform.position.x;
		foreach (Transform child in transform) {
			child.localPosition -= new Vector3(xDist, 0, 0);
		}

		//Add tiles to flip
		SpriteRenderer[] tiles = transform.GetComponentsInChildren<SpriteRenderer> ();
		int nextScore = gameManager.GetNextScore ();
		if (nextScore < 10) {
			tilesToFlip.Add (tiles [10].gameObject);
			tilesToFlip.Add (tiles [11].gameObject);
			tilesToFlip.Add (tiles [12].gameObject);
			tilesToFlip.Add (tiles [13].gameObject);
			tilesToFlip.Add (tiles [14].gameObject);
			tilesToFlip.Add (tiles [16].gameObject);
			tilesToFlip.Add (tiles [17].gameObject);
			tilesToFlip.Add (tiles [18].gameObject);
		}

		GeneratePlatformBase ();
	}

	public void GenerateTilesOutside(string scoreString){
		int OneCount = scoreString.Split('1').Length - 1;
//		print ("score string: " + scoreString);
//		print ("number of green tiles: " + OneCount);

		Vector3 centerPoint = GetCenterPoint();
		Bounds objectBounds = GetBounds ();
		float minX = -objectBounds.size.x / 2;
		float maxX = objectBounds.size.x / 2;
		float minY = -objectBounds.size.y / 2;
		float maxY = objectBounds.size.y / 2;

		float myX = 0;
		float myY = 0;

		int rightTiles, bottomTiles, topTiles;
		if(OneCount / 2 <= 7)
			rightTiles = OneCount / 2;
		else
			rightTiles = 7;

		if (OneCount - rightTiles <= 5) {
			bottomTiles = OneCount - rightTiles;
			topTiles = 0;
		} else {
			bottomTiles = (OneCount - rightTiles) / 2;
			topTiles = OneCount - rightTiles - bottomTiles;
		}
//
//		print ("Right: " + rightTiles);
//		print ("Bottom: " + bottomTiles);
//		print ("Top: " + topTiles);

		for (int i = 0; i < OneCount; i++) {
			//Vector3 spawnPos = FindPosOutside (objectBounds, i);
			GameObject greenTile = (GameObject)Instantiate (TileDrag, transform);
			greenTile.GetComponent<ITileInterface> ().SetTileCode (1);
			greenTile.GetComponent<TileDragBehaviour> ().dragFromOutside = true;

			Vector3 spawnPos;
			float randomPoint;
			float randomOffsetRight = Random.Range (0, 3);
			float randomOffsetX = Random.Range (-0.1f, 0.1f);
			float randomOffsetTop = Random.Range (2, 4);
			if (i < rightTiles) {
				randomPoint = Mathf.Lerp (minY, maxY - 2f, (float)i / (rightTiles - 1));
				myX = maxX + randomOffsetRight;
				myY = randomPoint + randomOffsetX;
				spawnPos = new Vector3 (myX, myY, 0);  
			} else if(i < rightTiles + bottomTiles) {
				randomPoint = Mathf.Lerp (minX + 2f, maxX - 2f, (float)(i - rightTiles) / (bottomTiles - 1));
				myX = randomPoint + randomOffsetX;
				myY = minY - randomOffsetRight;
				spawnPos = new Vector3 (myX, myY, 0);
			} else {
				randomPoint = Mathf.Lerp (minX + 2f, maxX - 2f, (float)(i - (rightTiles + bottomTiles)) / (topTiles - 1));
				myX = randomPoint + randomOffsetX;
				myY = maxY + randomOffsetTop;
				spawnPos = new Vector3 (myX, myY, 0);
			}
			greenTile.transform.localPosition = spawnPos;
		}

	}


	void GeneratePlatformBase(){

		Vector3 centerPoint = GetCenterPoint();
		Bounds objectBounds = GetBounds ();
		float yPos; 

		int nextScore = gameManager.GetNextScore ();
		levelSquare = Instantiate (SquareObject, transform);
		levelSquare.transform.localScale = levelSquare.transform.localScale * 1.6f;  
		levelSquare.transform.position = centerPoint + new Vector3(-objectBounds.extents.x - scoreCircleOffsetX, objectBounds.extents.y + 1f, 0);
		levelSquare.GetComponent<SpriteRenderer> ().color = LevelColour;

		currentScoreCircle = Instantiate (CircleObject, transform);
		Color _color = InProgressColour;
		_color.a = 0f;
		currentScoreCircle.GetComponent<SpriteRenderer> ().color = _color;
		currentScoreCircle.GetComponentInChildren<Text> ().text = nextScore.ToString();
		currentScoreCircle.GetComponentInChildren<Text> ().color = _color;
		currentScoreCircle.transform.localScale = currentScoreCircle.transform.localScale * 1.4f; 
		currentScoreCircle.transform.position = levelSquare.transform.position;

		currentScoreCirclePos = new Vector3(currentScoreCircle.transform.localPosition.x, 0, 0);


		prevScoreCircleFar = Instantiate (CircleObject, transform);
		_color = LevelColour;
		_color.a = 0f;
		prevScoreCircleFar.GetComponent<SpriteRenderer> ().color = _color;
		prevScoreCircleFar.transform.localScale = prevScoreCircleFar.transform.localScale * 1.1f;
		prevScoreCircleFar.transform.position = levelSquare.transform.position;
		float score = nextScore - 2;
		if (score < 0)
			score = 0;
		prevScoreCircleFar.GetComponentInChildren<Text> ().text = score.ToString();
		prevScoreCircleFar.GetComponentInChildren<Text> ().color = _color;
		yPos = Mathf.Lerp (objectBounds.max.y, currentScoreCirclePos.y, 1f / 3f);
		prevScoreCircleFarPos = new Vector3(prevScoreCircleFar.transform.localPosition.x, yPos, 0);

		prevScoreCircleNear = Instantiate (CircleObject, transform);
		_color = LevelColour;
		_color.a = 0f;
		prevScoreCircleNear.GetComponent<SpriteRenderer> ().color = _color;
		prevScoreCircleNear.transform.localScale = prevScoreCircleNear.transform.localScale * 1.2f;
		prevScoreCircleNear.transform.position = levelSquare.transform.position;
		score = nextScore - 1;
		if (score < 0)
			score = 0;
		prevScoreCircleNear.GetComponentInChildren<Text> ().text = score.ToString();
		prevScoreCircleNear.GetComponentInChildren<Text> ().color = _color;
		yPos = Mathf.Lerp (objectBounds.max.y, currentScoreCirclePos.y, 2f / 3f);
		prevScoreCircleNearPos = new Vector3(prevScoreCircleNear.transform.localPosition.x, yPos, 0);

		nextScoreCircleNear = Instantiate (CircleObject, transform);
		_color = NextColour;
		_color.a = 0f;
		nextScoreCircleNear.GetComponent<SpriteRenderer> ().color = _color;
		nextScoreCircleNear.transform.localScale = nextScoreCircleNear.transform.localScale * 1.2f;
		nextScoreCircleNear.transform.position = levelSquare.transform.position;
		nextScoreCircleNear.GetComponentInChildren<Text> ().text = (nextScore + 1).ToString();
		nextScoreCircleNear.GetComponentInChildren<Text> ().color = _color;

		yPos = Mathf.Lerp (objectBounds.min.y, currentScoreCirclePos.y, 2f / 3f);
		nextScoreCircleNearPos = new Vector3(nextScoreCircleNear.transform.localPosition.x, yPos, 0);

		nextScoreCircleFar = Instantiate (CircleObject, transform);
		_color = NextColour;
		_color.a = 0f;
		nextScoreCircleFar.GetComponent<SpriteRenderer> ().color = _color;
		nextScoreCircleFar.transform.localScale = nextScoreCircleFar.transform.localScale * 1.1f;
		nextScoreCircleFar.transform.position = levelSquare.transform.position;
		nextScoreCircleFar.GetComponentInChildren<Text> ().text = (nextScore + 2).ToString();
		nextScoreCircleFar.GetComponentInChildren<Text> ().color = _color;
		yPos = Mathf.Lerp (objectBounds.min.y, currentScoreCirclePos.y, 1f / 3f);
		nextScoreCircleFarPos = new Vector3(nextScoreCircleFar.transform.localPosition.x, yPos, 0);

		hintButton = Instantiate (HintObject, transform);
		_color = hintButton.GetComponent<SpriteRenderer> ().color;
		_color.a = 0f;
		hintButton.GetComponent<SpriteRenderer> ().color = _color;
		hintButton.transform.position = levelSquare.transform.position;
		float xPos = objectBounds.max.x;
		hintButtonPos = new Vector3(xPos + 0.5f, hintButton.transform.localPosition.y, 0);

		hintScreen = Instantiate (HintScreenObject, transform);
		hintScreen.transform.position = levelSquare.transform.position + new Vector3(1.4f, 1.5f, 0);
		hintScreenSize = hintScreen.transform.localScale;
		hintScreen.transform.localScale -= new Vector3 (hintScreen.transform.localScale.x, 0, 0);
		hintScreenCollapseSize = hintScreen.transform.localScale;
		showScoreCircles = true;



		timerCircle3Star = Instantiate (TimerCircleObject, transform);
		timerCircle3Star.transform.position = levelSquare.transform.position;
		xPos = Mathf.Lerp (objectBounds.min.x, objectBounds.max.x, 3f / 4f);
		timerCircle3Pos = new Vector3 (xPos, levelSquare.transform.position.y, levelSquare.transform.position.z);

		timerCircle2Star = Instantiate (TimerCircleObject, transform);
		timerCircle2Star.transform.position = levelSquare.transform.position;
		xPos = Mathf.Lerp (objectBounds.min.x, objectBounds.max.x, 2f / 4f);
		timerCircle2Pos = new Vector3 (xPos, levelSquare.transform.position.y, levelSquare.transform.position.z);

		timerCircle1Star = Instantiate (TimerCircleObject, transform);
		timerCircle1Star.transform.position = levelSquare.transform.position;
		xPos = Mathf.Lerp (objectBounds.min.x, objectBounds.max.x, 1f / 4f);
		timerCircle1Pos = new Vector3 (xPos, levelSquare.transform.position.y, levelSquare.transform.position.z);

		timerLine = Instantiate (TimerLineObject, transform);
		timerLine.transform.position = levelSquare.transform.position + new Vector3(1.4f, 0, 0.1f);
		if (nextScore >= 10) {
			timerLine.transform.localScale += new Vector3 (2.7f, 0, 0);
		}
		float xScale = Mathf.Lerp (0, timerLine.transform.localScale.x, 1f / 4f);
		timerLineCollapseSize = new Vector3 (xScale, timerLine.transform.localScale.y, timerLine.transform.localScale.z);

		timerSlider = Instantiate (TimerSliderObject, transform);
		timerSlider.transform.position = new Vector3 (objectBounds.max.x, levelSquare.transform.position.y, levelSquare.transform.position.z);
		timerSliderInitPos = timerSlider.transform.position;
		timerSlider.SetActive(false);
		timerStartCounter3 = timerStartCounter2 = timerStartCounter1 = 0;

		//Hint Screen Text
		if (nextScore == 0) {
			hintScreen.GetComponentInChildren<Text> ().text = hintDict ["HINT_BASIC"];
		} else if (nextScore == 1) {
			hintScreen.GetComponentInChildren<Text> ().text = hintDict ["HINT_ICON"];
		}
	}

	public void ScoreComplete(){
		ScoreCompleteFlag = true;
		//ShowHintScreenFlag = true;

		GetComponent<TimeManager> ().StopTimer ();
	}

	public void HideHintScreen(){
		ShowHintScreenFlag = false;
		HideHintScreenFlag = true;
	}

	public void ColourTimerCircles(){
		ColourTimerCirclesFlag = true;
	}

	public Bounds GetBounds(){

		Quaternion currRot = transform.rotation;
		transform.rotation = Quaternion.Euler (0, 0, 0);
		SpriteRenderer[] tiles = transform.GetComponentsInChildren<SpriteRenderer> ();
		Bounds bounds = new Bounds (transform.position, Vector3.zero);
		foreach (SpriteRenderer tile in tiles) {
			bounds.Encapsulate (tile.bounds);
		}
		transform.rotation = currRot;
		return bounds;
	}

	public Vector3 GetCenterPoint(){
		Transform[] tiles = transform.GetComponentsInChildren<Transform>();
		if (tiles.Length == 1) {
			return tiles [0].position;
		}

		var bounds = new Bounds (tiles [0].position, Vector3.zero);
		for (int i = 0; i < tiles.Length; i++) {
			bounds.Encapsulate (tiles [i].position);
		}
		return bounds.center;
	}



	public List<GameObject> ListOfTiles(){
		List<GameObject> tileList = new List<GameObject> ();
		foreach (Transform tile in this.transform) {
			if (tile.CompareTag ("tile")) {
				tileList.Add (tile.gameObject);
			}
		}
		return tileList;
	}


}
